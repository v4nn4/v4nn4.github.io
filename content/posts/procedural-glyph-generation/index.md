---
author: "v4nn4"
title: "Procedural Glyph Generation"
draft: true
date: "2024-02-24"
tags: ["glyph", "rust"]
ShowToc: false
ShowBreadCrumbs: false
math: katex
---

## Introduction

The Proto-Sinaitic script, emerging around 1800 BCE, marks the transition from pictorial representations to phonetic symbols, laying the foundation for modern alphabets. This script, derived from Egyptian hieroglyphs, simplified complex images into letters representing sounds, a crucial step in the evolution of writing.

{{< figure align=center width=200 src="/posts/procedural-glyph-generation/proto-sinaitic-script.png" >}}

Despite the significance of such innovations, the inertia of established writing systems and the extensive corpus of texts have made the introduction of new alphabets challenging. However, notable exceptions like the Korean Hangeul, designed in the 15th century for ease of learning and use, demonstrate the potential for successful alphabet creation.

In response to this history of innovation and the challenges of introducing new writing systems, I've developed an app that allows users to experiment with alphabet design. By manipulating strokes and applying rules, users can explore the creation of unique character sets. This tool aims to make the exploration of writing system design accessible to everyone, encouraging a deeper understanding of how alphabets evolve.

## Constraining the set of glyphs

- Except for the single stroke character, each stroke of a glyph must intersect at least once with another stroke
- Glyphs are invariant by any combination of the following transformations:
    - symmetry with respect to the x axis
    - symmetry with respect to the y axis
    - 90 degree rotation
- The first character encountered in an equivalence class will be chosen to represent it

The algorithm goes as follows:

1. By convention, start with the first stroke
2. Find 2-strokes glyphs by adding one of the remaining strokes to the single stroke
3. Check if they meet the criteria, that is if strokes intersect and if their equivalence class has been found
4. If the current glyph was already encountered, skip it
5. Find 3-strokes glyphs using 2-strokes glyphs, repeat until the unique k-glyph

Below is a visual representation of how the algorithm works. When a character is chosen (green), the subsequent paths that will encounter this glyph again will be skipped (grey).

{{< figure align=center width=360 src="/posts/procedural-glyph-generation/glyph_tree.svg" >}}

## Implementation

When implementing equality of glyphs and the `intersect` method, I found out that a much simpler point of view would be to rasterize everything and operate on matrices.

We choose a pixel width $k$ and rasterize each glyph, that is we create a square matrix of dimension $k$ of zeroes and ones representing the pixel intensities. For a glyph $g \in G$, we denote by $M^g$ such matrix. Then two glyphs $(g_1, g_2) \in G^2$ intersect if and only if

$$ M^{g_1} \odot M^{g_2} \neq 0_{k}$$

where $\odot$ is the element-wise product. We can also define equality between two glyphs as

$$ M^{g_1} = M^{g_2} $$

When adding a stroke to a glyph, we just add matrices and cap the values to one:

$$  \forall (i,j) , \ M_{i,j}^{g1 + g2} = \min \left( 1, M_{i,j}^{g_1} + M_{i,j}^{g_2} \right)$$

The rotation operation 


## 

---

```python
seen = Set()
result = {0: [Glyph(strokes)]}  # initialize with first stroke
for order, glyphs in result.items():  # iterate on order O(n)
    for glyph in glyphs:  # for each n-1 glyph, add a stroke and store if first of its kind, O(n) ?
        for stroke in strokes:  # O(n)
            if not intersect(glyph, stroke):
                continue
            next_glyph = Glyph(glyph.strokes + stroke)
            if next_glyph in seen:
                continue
            else:
                seen.append(next_glyph)
            if not is_equivalent(next_glyph, glyphs):
                result[order + 1].append(next_glyph)
```

---

# Implementation

The transformations are :

- Symmetry with respect to the x-axis $f_v$ (vertical flip)
- Symmetry with respect to the y-axis $f_h$ (horizontal flip)
- Rotation by $\theta=90^{\circ}$ degree around the z-axis $r_{\theta}$

Some interesting properties of those transformations:

- The first two are involutions, that is $ f_v^2 = f_h^2 = \textrm{id}$
- The rotation by $90^{\circ}$ satisfies $r_{\theta}^4 = \textrm{id}$
- $ f_v f_h = r^3 $
- Those transformations are commutative

Given those properties, we can show that the set generated by all composed transformations is 
$$ \mathcal{T} = \\{ f_v, f_h, r, f_v r, r^2, r^3, f_h r \\} $$

Here are their expression in terms of point coordinates $(x, y)$

$$ 
\begin{align}
    \textrm{id}(x, y) &= (+x, +y) \\\\
    f_v(x, y) &= (+x, -y) \\\\
    f_h(x, y) &= (-x, +y) \\\\
    r(x, y) &= (-x, -y) \\\\
    f_v r(x, y) &= (+y, +x) \\\\
    r^2(x, y) &= (+y, -x) \\\\
    r^3(x, y) &= (-y, +x) \\\\
    f_h r(x, y) &= (-y, -x)
\end{align}
$$

The strokes will be drawn from a set of anchor points. One interesting property is to ensure that the set of anchor points is invariant by all above transformations. This ensure that all glyphs are spacially bound to the same domain, even when they are fliped and rotated. This also means that all transformations are bijections from the set of anchor points to itself. This also applies to the set of strokes.

We will be working with $p$ anchor points. From those anchors points we derive

$$n = \frac{p(p-1)}{2}$$

strokes, which is also the number of handshakes in a group of $p$ people. For $p = 9$, this gives us $n=36$ strokes.

Since glyphs will be made of the same $n$ strokes, a representation can be a series of zeroes and ones representing the absence or presence of a stroke in the glyph:

$$ g = \sum_{i=0}^{n-1} a_i 2^{i}$$

This way, adding a stroke to a glyph can be written as a logical or operation. Transformations can be defined using a mapping table at anchor point level.

```python
p = 9
n = (p * (p - 1)) // 2
strokes = [2**i for i in range(n + 1)]  # 2^i for all i <= n

def get_strokes(glyph: int) -> List[int]:
    return [i for (s, i) in enumerate(strokes) if stroke == glyph & stroke]

def add(glyph1: int, glyph2: int) -> int:
    return glyph1 | glyph2

mapping_table = {
    # "fv": { ... },
    # ...
    # "r^3": { ... },
}

def transform(glyph: int) -> List[int]:
    result = []
    strokes = get_strokes(glyph)
    for key, fn in mapping_table.items():
        mapped_glyph = 0
        for s in strokes:
            mapped_glyph = add(mapped_glyph, fn[s])
        result.append(mapped_glyph)
    return result
```

We also need to handle intersections has we want to ensure that there are no hanging strokes within a glyph. This can also be done ahead of time using an adjacancy matrix.

$$ M_{i, j} = 1_{\textrm{intersect}(s_i, s_j)}$$

```python
adjacency_matrix = [[...], ..., [...]]  # 1 if strokes intersect, else 0

def are_strokes_intersecting(glyph: int) -> bool:
    indices = compute_stroke_indices(glyph)
    for i in indices:
        intersection_found = False
        for j in indices:
            if adjacency_matrix[i][j]:
                intersection_found = True
        if not intersection_found:
            return False
    return True
```

Then the generative algorithm goes as follows:

1. 

```python
def generate() -> List[int]:
    gs = {i: [] for i in range(n + 1)}  # order by number of strokes
    gs[0].append(s0)
    for i, g in glyphs.items():
        if i == 0:
            pass # already done with first index
        for s in strokes:
            g_next = add(g, s)
            if are_strokes_intersecting(g_next):
                gs_transformed = transform(g_next)
                if all(gs_transformed not in glyphs[i + 1]):
                    glyphs[i + 1].append(g_next)
```



# Optimization

[^1]: Albright, William F. 1969. The ProtoÂ­Sinaitic Inscriptions and Their Decipherment. Harvard Theological
Studies, XXII. 2nd printing. Cambridge: Harvard University Press.